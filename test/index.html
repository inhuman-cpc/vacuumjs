<p>浏览器要在屏幕上渲染内容，需要先构建 DOM 与 CSSOM 树。因此，我们需要确保将 HTML 和 CSS 尽可能快地提供给浏览器。</p><div><h3>Contents</h3><ol><li><a href="#dom">文档对象模型 (DOM)</a></li><li><a href="#css--cssom">CSS 对象模型 (CSSOM)</a></li></ol></div><div><h3>TL;DR</h3></div><h2>文档对象模型 (DOM)</h2><div><div><div><h2><a>Learn about DOM construction</a></h2><p>从视频、问答、讨论等等，现在上手</p><div><iframe></iframe></div></div></div></div><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critical Path<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/basic_dom.html">尝试完整样例</a></p></div><p>让我们从最简单的可能情况开始说：一个普通 HTML 网页，包含一些文字，一张图片。浏览器需要做什么才能处理这个简单页面呢？</p><p><img src="images/full-process.png"></p><ol><li><strong>转换：</strong>浏览器从磁盘或网络读取 HTML 的原始字节，然后根据指定的文件编码格式（例如 UTF-8）将其转换为相应字符。</li><li><strong>符号化：</strong>浏览器将字符串转换为 <a href="http://www.w3.org/TR/html5/">W3C HTML5 标准</a> 指定的各种符号 - 比如 “&lt;html&gt;“、”&lt;body&gt;” 及其他「尖括号」内的字符串。每个符号都有特殊含义并一套规则。</li><li><strong>词法分析：</strong>发射的符号转换为「对象」，定义它们的属性与规则。</li><li><strong>DOM 构建：</strong>最后，因为 HTML 标记定义不同标签间的相互关系（某些标签嵌套在其他标签中），所以创建的对象在树状数据结构中互相链接，树状数据结构还捕获原始标记中定义的父子关系：比如 <em>HTML</em> 对象是 <em>body</em> 对象的父对象，<em>body</em> 是 <em>paragraph</em> 对象的父对象等等。</li></ol><p><img src="images/dom-tree.png"></p><p><strong>上述整个流程的最终输出是文档对象模型，即这个简单网页的 “DOM”，浏览器使用它完成页面的所有后续处理。</strong></p><p>每次浏览器处理 HTML 标记，都要完成上述各个步骤：将字节转换为字符，确认符号，将符号转换为节点，然后构建 DOM 树。整个过程需要一些时间，处理大量 HTML 时更是如此。</p><p><img src="images/dom-timeline.png"></p><div><h3>Note</h3><ul><li>我们假定您对 Chrome DevTools 有基本了解 - 也就是说，您知道如何捕获网络瀑布图，或是录制时间轴。如果您需要快速重温，请访问 <a href="https://developer.chrome.com/devtools">Chrome DevTools 文档</a>，又或您是首次使用 DevTools，我们建议学习 Codeschool <a href="http://discover-devtools.codeschool.com/">发现 DevTools</a> 课程。</li></ul></div><p>如果您打开 Chrome DevTools，并在页面加载时录制时间轴，你可以看到执行这一步骤所需的实际时间 — 在上例中，将一堆 HTML 字节转换为 DOM 树大约需要 5 毫秒。当然，如果页面更大（大多数页面都是如此），这个过程需要的时间估计会更多。在后面创建流畅动画的章节中，您会看到，如果浏览器必须处理大量 HTML，这很可能变成你的瓶颈。</p><p>DOM 树准备就绪后，我们是否就有足够信息在屏幕上渲染页面了？还不行！DOM 树捕获文档标记的属性及关系，但没有告诉我们元素在渲染时是什么样子。这是 CSSOM 的责任，也就是我们接下来要讲的。</p><h2>CSS 对象模型 (CSSOM)</h2><p>浏览器在构建我们的简单页面 DOM 时，在文档的 head 部分碰上一个 link 标签，引用了外部 CSS 样式表 style.css。浏览器预见到它会需要这个资源来渲染页面，因此会立即发出一个该资源的请求，该请求返回以下内容：</p><div><div><pre><span>body</span> <span>{</span> <span>font-size</span><span>:</span> <span>16px</span> <span>}</span>
<span>p</span> <span>{</span> <span>font-weight</span><span>:</span> <span>bold</span> <span>}</span>
<span>span</span> <span>{</span> <span>color</span><span>:</span> <span>red</span> <span>}</span>
<span>p</span> <span>span</span> <span>{</span> <span>display</span><span>:</span> <span>none</span> <span>}</span>
<span>img</span> <span>{</span> <span>float</span><span>:</span> <span>right</span> <span>}</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/style.css">尝试完整样例</a></p></div><p>当然，我们本可以在 HTML 标记中直接声明样式（内联），但是，将 CSS 与 HTML 分开，我们就可以分离关注点：设计人员处理 CSS，开发人员关注 HTML，等等。</p><p>与 HTML 一样，我们需要将收到的 CSS 规则转换为浏览器可以理解、能够处理的东西。因此，我们再重复一次与处理 HTML 非常相似的过程：</p><p><img src="images/cssom-construction.png"></p><p>CSS 字节会转换为字符，然后转换为符号和节点，最后链接进树状结构上，即所谓「CSS 对象模型」，缩写为 CSSOM：</p><p><img src="images/cssom-tree.png"></p><p>CSSOM 为什么采用树状结构？ 在给页面上的一切对象计算最终的样式集时，浏览器会先从应用给该节点的最通用规则开始（例如，如果节点是 body 元素的子元素，则应用所有 body 样式），然后，通过应用更具体的规则递归细化计算的样式 - 亦即规则「向下层叠」。</p><p>再具体点说，我们来看一下上面的 CSSOM 树。body 元素中 <em>span</em> 标记内包含的任何文字均是 16 像素字体大小，红色文本 - font-size 指令从 body 向下层叠到 span。但是，如果 span 标签是 paragraph (p) 标签的子标签，则它的内容不会显示。</p><p>此外，请注意，上面的树不是完整的 CSSOM 树，它只显示了我们决定在样式表中覆盖的样式。每个浏览器都会提供一套默认的样式，也称为「用户代理样式」 – 即我们不提供任何自定义样式时看到的样式 – 我们的样式只是覆盖这些默认样式集（例如 <a href="http://www.iecss.com/">默认 IE 样式</a>）。如果您曾在 Chrome DevTools 中检查过「计算的样式」，并且想知道所有样式从何来，现在您应该知道答案了！</p><p>好奇 CSS 处理需要的时间？ 在 DevTools 中录制时间轴，并查找 “Recalculate Style” 事件：与 DOM 解析不同，timeline 不显示单独的 “Parse CSS” 条目，而是在 “Recalculate Style” 这一个事件下一同捕获解析、CSSOM 树的构建及计算的样式的递归计算。</p><p><img src="images/cssom-timeline.png"></p><p>处理我们的小样式表需要大约 0.6 毫秒，影响网页上的 8 个元素 – 时间不多，但也会产生成本。只不过，8 个元素从何而来呢？CSSOM 和 DOM 是独立的数据结构。结果证明，浏览器隐藏了一个重要步骤。接下来，让我们聊聊将 DOM 与 CSSOM 链接在一起的渲染树。</p>

********

<div><p>Out of date!</p><p>This article's translation is out of date with the English version. <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en">View in English</a>.</p></div><p>CSSOM 树与 DOM 树融合成一棵渲染树，随后计算每个可见元素的布局，并输出给绘制过程，在屏幕上渲染像素。优化这里的每一步对实现最佳渲染性能至关重要。</p><p>在前面的章节中，我们介绍了对象模型的构建，我们根据输入的 HTML 与 CSS 构建 DOM 树及 CSSOM 树。不过，它们是相互独立的对象，分别涵盖文档的不同面：一个描述内容，另一个描述应用于文档的样式规则。我们怎样合并它们然后让浏览器在屏幕上渲染像素呢？</p><div><h3>TL;DR</h3><ul><li>DOM 树与 CSSOM 树融合成渲染树。</li><li>渲染树只包括渲染页面需要的节点。</li><li>布局计算每个对象的精确位置及尺寸。</li><li>最后一步的绘制，输入确定的渲染树，在屏幕上渲染像素。</li></ul></div><p>对浏览器来说，第一步是将 DOM 树与 CSSOM 树融合成「渲染树」，这样它既网罗页面上所有可见的 DOM 内容，又涵盖每个节点的 CSSOM 样式信息。</p><p><img src="images/render-tree-construction.png"></p><p>为了构建渲染树，浏览器大致做了如下：</p><ol><li>从 DOM 树的根节点开始，遍历每个可见的节点。<ul><li>某些节点完全不可见（例如 script 标签、meta 标签等），因为它们不会在渲染结果中反映，所以会被忽略。</li><li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略。比方说，上面例子中的 span 节点，因为该节点有一条显式规则设置了 <code>display:none</code> 属性，所以不会出现在渲染树中。</li></ul></li><li>给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则。</li><li>发射可见节点，连带其内容及计算的样式。</li></ol><div><h3>注意</h3><ul><li>简单提一句，注意 `visibility: hidden` 与 `display: none` 是不一样的。前者隐藏元素，但该元素在布局中仍占据空间（即被渲染成一个空盒子），而后者 (display: none) 是直接从渲染树中整个地移除元素，该元素既不可见，也不属于布局。</li></ul></div><p>最终输出的渲染树包括了内容以及屏幕所有可见内容的样式信息。快要大功告成了！ <strong>有了渲染树，我们就能进入「布局」阶段。</strong></p><p>到目前为止，我们已经计算了哪些节点是可见的，以及它们的计算样式，但我们还没计算它们在设备<a href="/web/fundamentals/layouts/rwd-fundamentals/set-the-viewport.html">视口</a>中的准确位置与尺寸。这就是「布局」阶段（有时也称做「重排」）要做的工作。</p><p>为弄清每个对象的准确尺寸和位置，浏览器从渲染树的根节点开始遍历，以计算页面上每个对象的几何信息。下面就让我们动手做个简单例子：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critial Path: Hello world!<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;div</span> <span>style=</span><span>"width: 50%"</span><span>&gt;</span>
      <span>&lt;div</span> <span>style=</span><span>"width: 50%"</span><span>&gt;</span>Hello world!<span>&lt;/div&gt;</span>
    <span>&lt;/div&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/nested.html">尝试完整样例</a></p></div><p>上面页面的 body 包含两个嵌套 div：第一个 div（父元素）将节点尺寸设置为视口宽度的 50%，第二个包含在父元素中的 div 宽度为父元素的 50%，即视口宽度的 25%！</p><p><img src="images/layout-viewport.png"></p><p>布局过程输出一个「盒模型」，它精确捕获每个元素在视口中的准确位置及尺寸：所有相对度量单位都被转换为屏幕上的绝对像素位置，等等。</p><p>最后，既然我们知道了哪些节点可见，它们的计算的样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段，即把渲染树中的每个节点转换为屏幕上的实际像素 - 这一步通常称为「绘制」或者「栅格化」。</p><p>您都理解了吗？上述每一步都需要浏览器完成大量的工作，这也意味着它通常很耗时。所幸，Chrome DevTools 可以帮助我们深入了解上述三个阶段。让我们看一下最初的 “hello world” 示例中的布局阶段：</p><p><img src="images/layout-timeline.png"></p><ul><li>Timeline 中，”Layout” 事件捕获渲染树的构建及位置、尺寸的计算。</li><li>一旦布局完成，浏览器便发布 ‘Paint Setup’ 与 ‘Paint’ 事件，将渲染树转化为屏幕上的实际像素。</li></ul><p>渲染树的构建、布局与绘制所需的时间取决于文档大小、应用的样式，当然，还有运行文档的设备：文档越大，浏览器要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，绘制单色成本较低，而计算、呈现阴影的成本就非常高了）。</p><p>一旦完成上述步骤，我们的页面便在视口上可见了 - 呜呼！</p><p><img src="images/device-dom-small.png"></p><p>让我们快速回顾一下浏览器执行的所有步骤：</p><ol><li>处理 HTML 标记，构建 DOM 树。</li><li>处理 CSS 标记，构建 CSSOM 树。</li><li>将 DOM 树和 CSSOM 树融合成渲染树。</li><li>根据渲染树来布局，计算每个节点的几何信息。</li><li>在屏幕上绘制各个节点。</li></ol><p>我们的演示页面看起来也许很简单，但也需要完成大量工作。您觉得如果修改了 DOM 或 CSSOM，会怎样呢？我们将不得不重复上述所有步骤，以确定需要在屏幕上重新渲染的像素。</p><p><strong>优化关键渲染路径即尽可能地缩短上述第 1 步到第 5 步耗费的总时间。</strong> 这样，我们可以在屏幕上尽可能快地渲染内容，还可以缩短首次渲染后屏幕刷新之间的时间总量 - 也就是说，交互的内容可以有更高的刷新率。</p>

********

<p>默认情况下，CSS 被视为阻塞渲染的资源，这意味着在 CSSOM 构建完成前，浏览器会暂停渲染任何已处理的内容。确保精减你的 CSS，尽快传送它，并使用媒体类型与媒体查询来解除阻塞。</p><p>在上一节，我们看到了，关键渲染路径要求我们兼有 DOM 和 CSSOM 来构造渲染树，这就有一个重要的性能影响：<strong>HTML 和 CSS 都是阻塞渲染的资源。</strong> HTML 没什么说的，因为没有 DOM 我们就没有任何可渲染的内容，但是 CSS 的必要性可能就没那么明显。如果我们在 CSS 不阻塞的情况下尝试渲染一个普通页面会怎样？</p><div><h3>TL;DR</h3><ul><li>默认情况下，CSS 被视为阻塞渲染的资源。</li><li>媒体类型与媒体查询允许我们将一些 CSS 资源标记为不阻塞渲染。</li><li>所有的 CSS 资源，不论阻塞或不阻塞，浏览器都会下载。</li></ul></div><div><div><b>有 CSS 的纽约时报</b> <img src="images/nytimes-css-device.png"></div><div><b>没有 CSS 的纽约时报 (FOUC)</b> <img src="images/nytimes-nocss-device.png"></div></div><p>上面的例子，显示了纽约时报有 CSS 与没有 CSS 的情况，这证实了为什么要在 CSS 可用之前阻塞渲染 - 没有 CSS 的页面基本不可用。实际上，右侧的情况通常称为「内容样式短暂失效」(FOUC)。因此，在同时拥有 DOM 和 CSSOM 前，浏览器会阻塞渲染。</p><blockquote><p><strong><em>CSS 是阻塞渲染的资源，需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</em></strong></p></blockquote><p>但是，如果我们有一些 CSS 样式只在特定条件下使用，比如，页面打印，又或页面投影到大屏幕上？如果这些资源不阻塞渲染，那就太棒了！</p><p>CSS 「媒体类型」和「媒体查询」允许我们解决这类情况：</p><div><pre><code><span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
<span>&lt;link</span> <span>href=</span><span>"print.css"</span> <span>rel=</span><span>"stylesheet"</span> <span>media=</span><span>"print"</span><span>&gt;</span>
<span>&lt;link</span> <span>href=</span><span>"other.css"</span> <span>rel=</span><span>"stylesheet"</span> <span>media=</span><span>"(min-width: 40em)"</span><span>&gt;</span></code></pre></div><p><a href="/web/fundamentals/layouts/rwd-fundamentals/use-media-queries.html">媒体查询</a>由媒体类型以及零个或多个检查特定媒体特征的表达式组成。例如，我们的第一个样式表声明没有提供任何媒体类型或媒体查询，因此，将适用所有情况 - 换句话说，始终会阻塞渲染。另一方面，第二个样式表将只适用内容打印 - 也许您希望重排布局、更改字体，等等 - 因此，在页面首次加载时，这个样式表不需要阻塞渲染。最后一个样式表声明提供了媒体查询，由浏览器判定：如果条件符合，则在该样式表下载并处理完以前，浏览器阻塞渲染。</p><p>通过使用媒体查询，我们的外观可以根据不同使用场景定制，比如显示或打印，也可以根据不同情况比如屏幕方向改变、尺寸调整事件等定制。<strong>在声明样式表资源时，一定要多注意媒体类型和媒体查询，因为它们对关键渲染路径有极大的性能影响！</strong></p><div><div><h3>相关指南</h3><ul><li><p><a href="/web/fundamentals/layouts/rwd-fundamentals/use-media-queries">响应式 web 设计</a></p><a href="/web/fundamentals/layouts/rwd-fundamentals/use-media-queries">使用 CSS 媒体查询实现响应</a></li></ul></div></div><p>下面就让我们看一些简单例子：</p><div><pre><code><span>&lt;link</span> <span>href=</span><span>"style.css"</span>    <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
<span>&lt;link</span> <span>href=</span><span>"style.css"</span>    <span>rel=</span><span>"stylesheet"</span> <span>media=</span><span>"all"</span><span>&gt;</span>
<span>&lt;link</span> <span>href=</span><span>"portrait.css"</span> <span>rel=</span><span>"stylesheet"</span> <span>media=</span><span>"orientation:portrait"</span><span>&gt;</span>
<span>&lt;link</span> <span>href=</span><span>"print.css"</span>    <span>rel=</span><span>"stylesheet"</span> <span>media=</span><span>"print"</span><span>&gt;</span></code></pre></div><ul><li>第一条声明阻塞渲染，匹配所有情况。</li><li>第二条声明一样阻塞渲染：”all” 是默认类型，如果你未指定任何类型，则默认为 “all”。因此，第一条声明和第二条声明实际上是一样的。</li><li>第三条声明有一条动态媒体查询，在页面加载时判断。根据页面加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞。</li><li>最后一条声明只适用打印，因此，页面在浏览器中首次加载时，不会阻塞渲染。</li></ul><p>最后，请注意，「阻塞渲染」仅是指该资源是否会暂停浏览器的首次页面渲染。无论 CSS 是否阻塞渲染，CSS 资源都会被下载，只是说非阻塞性资源的优先级比较低而已。</p>

********

<p>JavaScript 允许我们修改页面的方方面面：内容、样式以及它如何响应用户交互。但是，JavaScript 也会阻塞 DOM 构建，延缓页面渲染。我们可以让我们的 JavaScript 异步加载，消除关键渲染路径中不必要的 JavaScript，来提供更佳性能。</p><div><h3>Contents</h3><ol><li><a href="#vs--javascript">解析器阻塞 vs. 异步 JavaScript</a></li></ol></div><div><h3>TL;DR</h3><ul><li>JavaScript 可以查询、修改 DOM 与 CSSOM。</li><li>JavaScript 的执行因 CSSOM 而阻塞。</li><li>除非明确声明 DOM 构建为异步，否则 JavaScript 会阻塞这一流程。</li></ul></div><p>JavaScript 是一门运行在浏览器上的动态语言，它允许我们修改页面上的种种：我们可以向 DOM 树添加或移除元素来修改页面内容，我们可以修改任一个元素的 CSSOM 属性，我们可以处理用户输入，等等。为了实际演示，我们用内联脚本扩展下之前的 “Hello World” 示例：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Script<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script&gt;</span>
      <span>var</span> <span>span</span> <span>=</span> <span>document</span><span>.</span><span>getElementsByTagName</span><span>(</span><span>'span'</span><span>)[</span><span>0</span><span>];</span>
      <span>span</span><span>.</span><span>textContent</span> <span>=</span> <span>'interactive'</span><span>;</span> <span>// change DOM text content</span>
      <span>span</span><span>.</span><span>style</span><span>.</span><span>display</span> <span>=</span> <span>'inline'</span><span>;</span>  <span>// change CSSOM property</span>
      <span>// create a new element, style it, and append it to the DOM</span>
      <span>var</span> <span>loadTime</span> <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>);</span>
      <span>loadTime</span><span>.</span><span>textContent</span> <span>=</span> <span>'You loaded this page on: '</span> <span>+</span> <span>new</span> <span>Date</span><span>();</span>
      <span>loadTime</span><span>.</span><span>style</span><span>.</span><span>color</span> <span>=</span> <span>'blue'</span><span>;</span>
      <span>document</span><span>.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>loadTime</span><span>);</span>
    <span>&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/script.html">尝试完整样例</a></p></div><ul><li><p>JavaScript 允许我们进入 DOM，取得隐藏的 span 节点的引用，该节点可能不在渲染树中出现，但它仍在 DOM 里。有了引用后，我们就可以修改它的文本（通过 .textContent），甚至可以将其计算的 display 样式属性从 ‘none’ 改成 ‘inline’。完成上述后，我们的页面现在会显示 “<strong>Hello interactive students!</strong>“。</p></li><li><p>JavaScript 还允许我们在 DOM 上创建、样式化，然后添加或移除新元素。事实上，技术上说，我们的整个页面可以只是一个大 JavaScript 文件，逐个创建并样式化元素 - 这种方法行得通，但实践中使用 HTML 和 CSS 要简单得多。在我们的 JavaScript 函数的第二部分，我们创建了一个新 div 元素，设置它的文本内容，样式化它，然后将它添加到 body 中。</p></li></ul><p><img src="images/device-js-small.png"></p><p>这样，我们修改了现有 DOM 节点的内容与 CSS 样式，在文档中添加了一个全新节点。我们的页面不会赢得任何设计奖，但是它演示了 JavaScript 赋予我们的力量与灵活。</p><p>只不过，这里潜藏着一个大的性能问题。JavaScript 赋予我们许多能力，但它也同时给页面如何及何时渲染带来了许多额外限制。</p><p>首先，请注意，上面示例中，我们的内联脚本靠近页面底部。为什么？你应该自己试一把。如果我们把脚本移到 <em>span</em> 元素上方，你会发现脚本不起作用，并提示无法在文档中找到任何 <em>span</em> 元素的引用，即 <em>getElementsByTagName(‘span’)</em> 会返回 <em>null</em>。这透露一个重要事实：我们的脚本在文档的哪儿插入，即在哪儿执行。HTML 解析器遇到一个 script 标签，它会暂停构建 DOM，并移交控制权给 JavaScript 引擎；等 JavaScript 引擎执行完毕，浏览器从中断的地方恢复 DOM 构建。</p><p>换句话说，我们的脚本块找不到页面中靠后的元素，因为这些元素尚未处理到。或者，稍微换个说法：<strong>执行内联脚本会阻塞 DOM 构建，也就延缓了首次渲染。</strong></p><p>页面上引用脚本的另一个微妙事实是，它们不仅可以读取、修改 DOM，它们还可以读取、修改 CSSOM。事实上，这也正是我们在例子中所做的，将 span 元素的 display 属性从 none 改为 inline。最终结果？我们现在有一个竞态。</p><p>如果浏览器尚未完成 CSSOM 下载与构建，而我们就想运行我们的脚本，会怎样？答案很简单，对性能不好：<strong>浏览器会延迟脚本执行，直到完成 CSSOM 下载与构建，而在我们等待时，DOM 构建同样被阻塞。</strong></p><p>简言之，JavaScript 在 DOM、CSSOM 和 JavaScript 执行间引入了很多新的依存关系，导致浏览器在处理和渲染页面上出现大幅延迟：</p><ol><li>脚本在文档中的位置很重要。</li><li>遇到 script 标签时，DOM 构建停止，直到脚本执行完毕。</li><li>JavaScript 可以查询、修改 DOM 和 CSSOM。</li><li>CSSOM 准备就绪前，JavaScript 执行被延后。</li></ol><p>我们谈论「优化关键渲染路径」时，很大程度上是在谈论理解、优化 HTML、CSS 与 JavaScript 之间的依存关系谱。</p><h2>解析器阻塞 vs. 异步 JavaScript</h2><p>默认情况下，JavaScript 执行会阻塞解析器：当浏览器在文档中遇到一个 script，它必须暂停 DOM 构建，移交控制权给 JavaScript 运行时，让脚本先执行，然后才继续处理 DOM。在前面的示例中，我们已经了解内联脚本的情况。事实上，内联脚本始终会阻塞解析器，除非你十分小心，编写额外代码来推迟它们的执行。</p><p>通过 script 标签引入的脚本又怎样？让我们拿前面的示例说，把代码提取到一个单独文件中：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Script External<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>src=</span><span>"app.js"</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/split_script.html">尝试完整样例</a></p></div><p><strong>app.js</strong></p><div><div><pre><span>var</span> <span>span</span> <span>=</span> <span>document</span><span>.</span><span>getElementsByTagName</span><span>(</span><span>'span'</span><span>)[</span><span>0</span><span>];</span>
<span>span</span><span>.</span><span>textContent</span> <span>=</span> <span>'interactive'</span><span>;</span> <span>// change DOM text content</span>
<span>span</span><span>.</span><span>style</span><span>.</span><span>display</span> <span>=</span> <span>'inline'</span><span>;</span>  <span>// change CSSOM property</span>
<span>// create a new element, style it, and append it to the DOM</span>
<span>var</span> <span>loadTime</span> <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>);</span>
<span>loadTime</span><span>.</span><span>textContent</span> <span>=</span> <span>'You loaded this page on: '</span> <span>+</span> <span>new</span> <span>Date</span><span>();</span>
<span>loadTime</span><span>.</span><span>style</span><span>.</span><span>color</span> <span>=</span> <span>'blue'</span><span>;</span>
<span>document</span><span>.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>loadTime</span><span>);</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/app.js">尝试完整样例</a></p></div><p>你觉得我们使用 <code>&lt;script&gt;</code> 标签代替内联 JavaScript 代码段，执行顺序会有所不同吗？答案是不会，因为这些代码是一样的，所以结果会一样。在两个示例中，浏览器均须先暂停，然后执行脚本，之后才能处理文档的剩余部分。只不过说，<strong>在外部 JavaScript 文件情况中，浏览器必须暂停，然后等待脚本从磁盘、缓存或远程服务器中取回，这就又可能给我们的关键渲染路径增加了数以万毫秒计的延迟。</strong></p><p>尽管如此，好消息是，我们有应急出口。默认情况下，所有 JavaScript 均会阻塞解析器，因为浏览器不知道脚本想在页面上做什么，因此它必须假定最糟的状况并阻塞解析器。但是，如果我们能够告知浏览器说，脚本无需在文档中引用它的确切位置被执行呢？如此一来，浏览器会继续构建 DOM，并在脚本准备就绪后（比如，从缓存或远程服务器中加载完文件）执行脚本。</p><p>那么，我们如何实现这种方法呢？很简单，我们可以将脚本标记为 <em>async</em>：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Script Async<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>src=</span><span>"app.js"</span> <span>async</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/split_script_async.html">尝试完整样例</a></p></div><p>将 async 关键字添加到 script 标签，告诉浏览器，在它等脚本准备就绪前不应阻塞 DOM 构建，这将是性能上的巨大提升！</p>

********

<p>无法评估就谈不上优化。幸运的是，Navigation Timing API 提供了所有必备工具来评估关键呈现路径的每个步骤！</p><div><h3>TL;DR</h3><ul><li>Navigation Timing 为评估关键呈现路径提供了细粒度的时间戳。</li><li>浏览器发出一系列可捕获的事件，捕获关键呈现路径的不同阶段。</li></ul></div><p>作为每个有效性能策略的基础，准确的评估和检测必不可少。这也就是 Navigation Timing API 所提供的。</p><p><img src="images/dom-navtiming.png"></p><p>上图中的每一个标签对应着浏览器为加载的每个网页跟踪的细粒度时间戳。实际上，在这个具体的例子中，我们只展现了各种不同的时间戳中的一部分而已 - 我们暂且跳过所有与网络有关的时间戳，但是在后面的课程中还会详细介绍。</p><p>那么，这些时间戳到底有什么含义呢？</p><ul><li><strong>domLoading：</strong>这是整个过程开始的时间戳，浏览器开始解析 HTML 文档第一批收到的字节 document.</li><li><strong>domInteractive：</strong>标记浏览器完成解析并且所有 HTML 和 DOM 构建完毕的时间点。</li><li><strong>domContentLoaded：</strong>标记 DOM 准备就绪并且没有样式表阻碍 JavaScript 执行的时间点 - 意味着我们可以开始构建呈现树了。<ul><li>很多 JavaScript 框架等待此事件发生后，才开始执行它们自己的逻辑。因此，浏览器会通过捕获 <em>EventStart</em> 和 <em>EventEnd</em> 时间戳，跟踪执行逻辑所需的时间。</li></ul></li><li><strong>domComplete：</strong> 顾名思义，所有的处理完成，网页上所有资源（图片等） 下载完成 - 即加载旋转图标停止旋转。</li><li><strong>loadEvent：</strong>作为每个网页加载的最后一步，浏览器会触发<code>onLoad</code>事件，以便触发附加的应用逻辑。</li></ul><p>HTML 规范中指明了每一个事件的具体条件：什么时候触发，什么条件触发等等。在我们的教程中，会重点着眼于与关键呈现路径有关的一些关键里程碑：</p><ul><li><strong>domInteractive</strong> 标记 DOM 准备就绪。</li><li><strong>domContentLoaded</strong> 通常标记 [DOM 和 CSSOM 都准备就绪] 的时间 (http://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)。<ul><li>如果没有解析器阻塞 JavaScript，<em>DOMContentLoaded</em> 会在 <em>domInteractive</em> 之后立即触发。</li></ul></li><li><p><strong>domComplete</strong> 标记网页及其所有附属资源都已经准备就绪的时间。</p></li></ul><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Measure<span>&lt;/title&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
    <span>&lt;script&gt;</span>
      <span>function</span> <span>measureCRP</span><span>()</span> <span>{</span>
        <span>var</span> <span>t</span> <span>=</span> <span>window</span><span>.</span><span>performance</span><span>.</span><span>timing</span><span>,</span>
          <span>interactive</span> <span>=</span> <span>t</span><span>.</span><span>domInteractive</span> <span>-</span> <span>t</span><span>.</span><span>domLoading</span><span>,</span>
          <span>dcl</span> <span>=</span> <span>t</span><span>.</span><span>domContentLoadedEventStart</span> <span>-</span> <span>t</span><span>.</span><span>domLoading</span><span>,</span>
          <span>complete</span> <span>=</span> <span>t</span><span>.</span><span>domComplete</span> <span>-</span> <span>t</span><span>.</span><span>domLoading</span><span>;</span>
        <span>var</span> <span>stats</span> <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>'p'</span><span>);</span>
        <span>stats</span><span>.</span><span>textContent</span> <span>=</span> <span>'interactive: '</span> <span>+</span> <span>interactive</span> <span>+</span> <span>'ms, '</span> <span>+</span>
            <span>'dcl: '</span> <span>+</span> <span>dcl</span> <span>+</span> <span>'ms, complete: '</span> <span>+</span> <span>complete</span> <span>+</span> <span>'ms'</span><span>;</span>
        <span>document</span><span>.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>stats</span><span>);</span>
      <span>}</span>
    <span>&lt;/script&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body</span> <span>onload=</span><span>"measureCRP()"</span><span>&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/measure_crp.html">尝试完整样例</a></p></div><p>上面的例子乍一看可能有点晕，但是它确实已经很简单了。Navigation Timing API 捕获所有相关的时间戳，而我们的代码只是等待 <code>onload</code> 事件触发 - 回忆一下，onLoad 事件在 domInteractive、domContentLoaded 和 domComplete 之后触发 - 然后计算各个时间戳之间的间隔。 <img src="images/device-navtiming-small.png"></p><p>通过上面的介绍和示例，我们现在知道了要跟踪哪些具体的里程碑以及用于输出这些评估结果的简单功能。注意，除了直接将评估结果显示在网页上，还可以修改代码，将这些评估结果发送到分析服务器上。（<a href="https://support.google.com/analytics/answer/1205784?hl=en">Google Analytics 可以自动完成这些功能</a>），这是一种很有效的监控网页性能的方法，可以由此找出哪些网页还需要进一步优化性能。&lt;/cf&gt;</p>

********

<p>确定并解决关键呈现路径性能方面的瓶颈需要了解很多常见问题。让我们开始实践之旅，并找出常用的性能模式，从而帮助您优化网页。</p><div><h3>Contents</h3><ol><li><a href="#hello-world-experience">Hello World experience</a></li><li><a href="#javascript--css">结合使用 JavaScript 和 CSS</a></li><li><a href="#section">性能模式</a></li></ol></div><p>优化关键呈现路径的目标是允许浏览器尽可能快地绘制网页：较快的页面呈现速度可以提高互动度、增加网页浏览量并<a href="http://www.google.com/think/multiscreen/success.html">提高转化率</a>。因此，我们希望通过优化要加载的资源和加载顺序，尽可能减少访问者注视空白屏幕的时间。</p><p>为了更好地介绍这一过程，我们先从最简单的情况开始讲解，逐步构建我们的网页，使其包含更多资源、样式和应用逻辑；在此过程中，我们还会了解出错的位置，以及如何优化每种情况。</p><p>最后，在开始之前，我们还要处理一件事…到目前为止，我们一直专注于资源（CSS、JS 或 HTML 文件）可进行处理之后浏览器中会发生什么，但忽略了从缓存或网络中提取资源的时间。在下一课中，我们将深入研究如何细致优化应用的网络方面，但同时（为了更贴近现实）我们将做出以下假设：</p><ul><li>到服务器的网络往返（传播延迟）将花费 100 毫秒</li><li>HTML 文档的服务器响应时间为 100 毫秒，而其他所有文件的响应时间均为 10 毫秒</li></ul><h2>Hello World experience</h2><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: No Style<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/basic_dom_nostyle.html">尝试完整样例</a></p></div><p>我们将从基本的 HTML 标记和单个无 CSS 或 JavaScript 的图片开始，这与获得图片一样简单。现在，我们在 Chrome DevTools 中打开网络时间轴，并检查生成的资源瀑布流：</p><p><img src="images/waterfall-dom.png"></p><p>不出所料，HTML 文件的下载时间大约为 200 毫秒。注意，蓝色线的透明部分表示浏览器在网络上等待（即尚未收到任何响应字节）的时间，而实体部分则显示收到第一个响应字节之后完成下载的时间。在上述示例中，HTML 下载量极少（不足 4K），因此我们仅需单个往返过程即可提取整个文件。因此，提取 HTML 文档大约耗时 200 毫秒，其中一半的时间花费在等待网络上，而另一半花费在服务器响应上。</p><p>HTML 内容准备就绪后，浏览器必须解析字节、将其转换为令牌，并构建 DOM 树。注意，DevTools 可以方便地在底部报告 <code>DOMContentLoaded</code> 事件的时间（216 毫秒），该时间也与蓝色垂直线相对应。HTML 下载结束和蓝色垂直线 (DOMContentLoaded) 之间的间隔是浏览器构建 DOM 树花费的时间，在此示例中仅为几毫秒。</p><p>最后，请注意一些有趣的事情：我们的’趣照’没有阻止 <code>domContentLoaded</code> 事件！ 这证明，我们无需等待网页上的每个资源即可构建呈现树甚至绘制网页：<strong>不是所有资源均对提供首次描绘起重要作用</strong>。事实上，就像我们将要看到的，我们谈论关键呈现路径时，通常谈论的是 HTML 标记、CSS 和 JavaScript。图片不会阻止网页的首次呈现，尽管如此，我们也应努力确保系统尽快绘制图片！</p><p>不过，系统会阻止图片上的<code>load</code>事件（亦常称为<code>onload</code>）：DevTools 在 335 毫秒时报告 onload 事件。回想一下，onload 事件标记的点是网页所需的<strong>所有资源</strong>均已下载并经过处理的点，这是加载微调控件可以在浏览器中停止微调的点，并且该点使用瀑布流中的红色垂直线进行标记。</p><h2>结合使用 JavaScript 和 CSS</h2><p>我们的’Hello World experience’页面表面看起来可能非常简单，但我们需要做大量的工作才能使其呈现出这种效果！ 不过在实践中，我们还需要 HTML 之外的很多资源：我们可能需要 CSS 样式表以及一个或多个添加网页互动性的脚本。我们将两者组合起来，看看会发生什么：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Measure Script<span>&lt;/title&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body</span> <span>onload=</span><span>"measureCRP()"</span><span>&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>src=</span><span>"timing.js"</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/measure_crp_timing.html">尝试完整样例</a></p></div><p><em>添加 JavaScript 和 CSS 之前：</em></p><p><img src="images/waterfall-dom.png"></p><p><em>添加 JavaScript 和 CSS 之后：</em></p><p><img src="images/waterfall-dom-css-js.png"></p><p>添加外部 CSS 和 JavaScript 文件额外增加了两个针对瀑布流的请求（浏览器几乎会同时分派这两个请求），目前一切顺利。但请注意，<strong>现在，domContentLoaded 事件和 onload 事件之间的时间差小多了。这是怎么回事？</strong></p><ul><li>与纯 HTML 示例不同，我们现在还需要提取并解析 CSS 文件以构建 CSSOM，而且我们必须使用 DOM 和 CSSOM 来构建呈现树。</li><li>因为我们的网页上还有一个阻止解析器的 JavaScript 文件，因此在系统下载并解析 CSS 文件之前，domContentLoaded 事件将被阻止：JavaScript 可能会查询 CSSOM，因此在执行 JavaScript 之前，我们必须阻止和等待 CSS。</li></ul><p><strong>如果我们使用内联脚本代替外部脚本会怎样？</strong>表面上看这是一个微不足道的问题，但实际上却非常棘手。结果证明，即使将脚本直接内联到网页中，浏览器得知脚本意图的唯一可靠方式还是执行该脚本，而且正如我们了解的那样，在 CSSOM 构建完成之前，我们不能直接内联脚本。简言之，内联 JavaScript 也会阻止解析器。</p><p>不过，虽然内联脚本会阻止 CSS，但此操作仍可以加快网页呈现速度吗？ 如果最后一种情况很棘手，那这个问题会更棘手！ 我们试着操作下，看看会发生什么…</p><p><em>外部 JavaScript：</em></p><p><img src="images/waterfall-dom-css-js.png"></p><p><em>内联 JavaScript：</em></p><p><img src="images/waterfall-dom-css-js-inline.png"></p><p>我们减少了一个请求，但是 onload 和 domContentLoaded 的时间仍没有变化，为什么？ 这与 JavaScript 是内联的还是外部的没有关系，因为只要浏览器遇到脚本代码，它就会阻止和等待，直到 CSSOM 构建完成。另外，在我们的第一个示例中，浏览器是同时下载 CSS 和 JavaScript 的，而且下载行为几乎是在同一时间完成的。因此，在这一特定实例中，内联 JavaScript 代码没有太大意义！ 那我们就陷入僵局，没法提高网页呈现速度了吗？ 实际上，我们有多个不同的应对策略。</p><p>首先回想一下，所有内联脚本均会阻止解析器，但是对于外部脚本来说，我们可以添加<code>async</code>关键字来取消阻止解析器。我们来取消内联，并尝试一下上述方法：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Measure Async<span>&lt;/title&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body</span> <span>onload=</span><span>"measureCRP()"</span><span>&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>async</span> <span>src=</span><span>"timing.js"</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/measure_crp_async.html">尝试完整样例</a></p></div><p>阻止解析器的（外部）JavaScript：__</p><p><img src="images/waterfall-dom-css-js.png"></p><p>异步（外部）JavaScript：__</p><p><img src="images/waterfall-dom-css-js-async.png"></p><p>好多了！ 解析 HTML 之后不久即会触发 domContentLoaded 事件：浏览器已得知不要阻止 JavaScript，而且因为没有其他阻止解析器的脚本，CSSOM 构建也可以同步进行了。</p><p>或者，我们也可以尝试另外一种方法，即同时内联 CSS 和 JavaScript：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: Measure Inlined<span>&lt;/title&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;style&gt;</span>
      <span>p</span> <span>{</span> <span>font-weight</span><span>:</span> <span>bold</span> <span>}</span>
      <span>span</span> <span>{</span> <span>color</span><span>:</span> <span>red</span> <span>}</span>
      <span>p</span> <span>span</span> <span>{</span> <span>display</span><span>:</span> <span>none</span> <span>}</span>
      <span>img</span> <span>{</span> <span>float</span><span>:</span> <span>right</span> <span>}</span>
    <span>&lt;/style&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script&gt;</span>
      <span>var</span> <span>span</span> <span>=</span> <span>document</span><span>.</span><span>getElementsByTagName</span><span>(</span><span>'span'</span><span>)[</span><span>0</span><span>];</span>
      <span>span</span><span>.</span><span>textContent</span> <span>=</span> <span>'interactive'</span><span>;</span> <span>// change DOM text content</span>
      <span>span</span><span>.</span><span>style</span><span>.</span><span>display</span> <span>=</span> <span>'inline'</span><span>;</span>  <span>// change CSSOM property</span>
      <span>// create a new element, style it, and append it to the DOM</span>
      <span>var</span> <span>loadTime</span> <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>);</span>
      <span>loadTime</span><span>.</span><span>textContent</span> <span>=</span> <span>'You loaded this page on: '</span> <span>+</span> <span>new</span> <span>Date</span><span>();</span>
      <span>loadTime</span><span>.</span><span>style</span><span>.</span><span>color</span> <span>=</span> <span>'blue'</span><span>;</span>
      <span>document</span><span>.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>loadTime</span><span>);</span>
    <span>&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/measure_crp_inlined.html">尝试完整样例</a></p></div><p><img src="images/waterfall-dom-css-inline-js-inline.png"></p><p>注意：<em>domContentLoaded</em> 时间与前面示例中的时间没有区别：我们没有将 JavaScript 设置为异步，而是将 CSS 和 JS 同时内联到网页本身。这使得我们的 HTML 网页更大，但好处是浏览器无需等待提取外部资源，每个元素都已纳入网页。</p><p>如您所见，即使是非常简单的网页，优化关键呈现路径也不是一件轻而易举的事情：我们需要了解不同资源之间的依存关系图，需要确定哪些资源是’重要资源’，而且我们必须在名目繁多的策略中做出选择，找出在网页中添加这些资源的恰当方式。该问题不是一个方案可以解决的，每个网页都不尽相同，因此您必须按照相似的解决流程，找出最佳策略。</p><p>不过，我们可以回过头来，看看能否找出某些常规性能模式…</p><h2>性能模式</h2><p>最简单的可用网页仅由 HTML 标记组成：无 CSS、JavaScript 或其他类型的资源。要呈现此网页，浏览器必须初始化请求、等待 HTML 文档准备就绪、对其进行解析、构建 DOM，最后使其呈现在屏幕上：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;title&gt;</span>Critical Path: No Style<span>&lt;/title&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/basic_dom_nostyle.html">尝试完整样例</a></p></div><p><img src="images/analysis-dom.png"></p><p><strong>T<sub>0</sub> 和 T<sub>1</sub> 之间的时间用于捕获网络和服务器处理时间。</strong> 在最理想的情况（HTML 文件较小）下，我们仅需一个网络往返过程即可提取整个文档；由于 TCP 传输协议的工作方式，较大的文件可能需要多个往返过程，我们将在以后的课程中重新探讨这一主题。<strong>因此，在最理想的情况下，上述网页具有一个往返过程（最少）关键呈现路径。</strong></p><p>现在，我们看一下带有外部 CSS 文件的同一网页：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/analysis_with_css.html">尝试完整样例</a></p></div><p><img src="images/analysis-dom-css.png"></p><p>再重复一下，我们需要一个网络往返过程来提取 HTML 文档，然后检索到的标记告知我们还需要 CSS 文件：这意味着，浏览器必须返回服务器并获取 CSS，然后才能在屏幕上呈现网页。<strong>因此，该网页最少需要两个往返过程才能显示</strong>，重复一下，CSS 文件可能需要多个往返过程，因此重点在’最少’。</p><p>我们来定义将用于描述关键呈现路径的词汇：</p><ul><li><strong>关键资源</strong>：可能阻止网页首次呈现的资源。</li><li><strong>关键路径长度</strong>：即往返过程数量，或提取所有关键资源所需的总时间。</li><li><strong>关键字节</strong>：实现网页首次呈现所需的总字节数，是所有关键资源的传输文件大小总和。 带有一个 HTML 网页的首个示例包含一项关键资源（HTML 文档），关键路径长度也与 1 个网络往返过程（假设文件较小）相等，而且总的关键字节数正好是 HTML 文档本身的传输大小。</li></ul><p>现在，我们将其与’HTML + CSS’示例的关键路径特征对比一下：</p><p><img src="images/analysis-dom-css.png"></p><ul><li><strong>2</strong> 种关键资源</li><li><strong>2</strong> 个或更多往返过程的最短关键路径长度</li><li><strong>9</strong> KB 的关键字节</li></ul><p>我们必须同时使用 HTML 和 CSS 来构建呈现树，因此 HTML 和 CSS 均为关键资源：浏览器仅在获取 HTML 文档之后提取 CSS，因此关键路径长度最短为两个往返过程；两种资源加起来的关键字节总量最多为 9 KB。</p><p>现在我们再向组合中添加一个额外的 JavaScript 文件！</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>src=</span><span>"app.js"</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/analysis_with_css_js.html">尝试完整样例</a></p></div><p>我们添加了 app.js（网页上的外部 JavaScript 资源），而且据我们目前所了解的，这是一种解析器阻止（即关键）资源。更糟的是，为了执行 JavaScript 文件，我们还必须阻止并等待 CSSOM；注意，在<code>style.css</code>下载和 CSSOM 构建完成之前，浏览器将会暂停。</p><p><img src="images/analysis-dom-css-js.png"></p><p>不过，如果我们实际查看该网页的’网络瀑布流’，就会发现 CSS 和 JavaScript 请求几乎会在同一时间初始化：浏览器获取 HTML，发现这两种资源并初始化这两个请求。因此，上述网页具有以下关键路径特征：</p><ul><li><strong>3</strong> 种关键资源</li><li><strong>2</strong> 个或更多往返过程的最短关键路径长度</li><li><strong>11</strong> KB 的关键字节</li></ul><p>现在，我们拥有三种关键资源，关键字节总量最多为 11 KB，但是我们的关键路径长度仍然是两个往返过程，因为我们可以同时传输 CSS 和 JavaScript！ <strong>了解关键呈现路径的特征意味着能够确定关键资源，并了解浏览器将如何安排它们的提取时间。</strong> 我们继续分析示例…</p><p>与网站开发者交流之后，我们意识到网页中添加的 JavaScript 不必是阻止脚本：我们的某些分析和其他代码不会阻止网页呈现。了解这些后，我们就可以向脚本代码中添加<code>async</code>属性，以取消对解析器的阻止：</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span><span>&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>src=</span><span>"app.js"</span> <span>async</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/analysis_with_css_js_async.html">尝试完整样例</a></p></div><p><img src="images/analysis-dom-css-js-async.png"></p><p>对脚本进行异步编程具有以下几项优势：</p><ul><li>脚本再也不会阻止解析器，也不再是关键呈现路径的组成部分</li><li>因为没有其他关键脚本，CSS 也不需要阻止 domContentLoaded 事件</li><li>domContentLoaded 事件触发得越早，其他应用逻辑开始执行的时间就越早</li></ul><p>因此，我们经过优化的网页恢复到了具有两种关键资源（HTML 和 CSS）、具有两个往返过程的最短关键路径长度和 9 KB 的关键字节总量。</p><p>最后，假设 CSS 样式表仅用于打印， 那会如何呢？</p><div><div><pre><span>&lt;html&gt;</span>
  <span>&lt;head&gt;</span>
    <span>&lt;meta</span> <span>name=</span><span>"viewport"</span> <span>content=</span><span>"width=device-width,initial-scale=1"</span><span>&gt;</span>
    <span>&lt;link</span> <span>href=</span><span>"style.css"</span> <span>rel=</span><span>"stylesheet"</span> <span>media=</span><span>"print"</span><span>&gt;</span>
  <span>&lt;/head&gt;</span>
  <span>&lt;body&gt;</span>
    <span>&lt;p&gt;</span>Hello <span>&lt;span&gt;</span>web performance<span>&lt;/span&gt;</span> students!<span>&lt;/p&gt;</span>
    <span>&lt;div&gt;&lt;img</span> <span>src=</span><span>"awesome-photo.jpg"</span><span>&gt;&lt;/div&gt;</span>
    <span>&lt;script </span><span>src=</span><span>"app.js"</span> <span>async</span><span>&gt;&lt;/script&gt;</span>
  <span>&lt;/body&gt;</span>
<span>&lt;/html&gt;</span>
</pre></div><p><a href="https://googlesamples.github.io/web-fundamentals/samples/fundamentals/performance/critical-rendering-path/analysis_with_css_nb_js_async.html">尝试完整样例</a></p></div><p><img src="images/analysis-dom-css-nb-js-async.png"></p><p>因为 style.css 资源仅用于打印，因此，浏览器不必阻止它就可以呈现网页。因此，只要 DOM 构建完成，浏览器即具有了呈现网页的足够信息！ 所以，该网页仅具有一种关键资源（HTML 文档），最小关键呈现路径长度为一个往返过程。</p>

********

<div><p>Out of date!</p><p>This article's translation is out of date with the English version. <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=en">View in English</a>.</p></div><p>为了尽快完成首次呈现，我们需要优化下列三种变量：</p><ul><li><strong>尽量减少关键资源数量。</strong></li><li><strong>尽量减少关键字节数。</strong></li><li><strong>尽量缩短关键路径的长度。</strong></li></ul><p>关键资源是任何可能阻止网页首次呈现的资源。网页上的关键资源越少，浏览器在屏幕上显示内容时必须完成的工作量就越少，对 CPU 和其他资源的占用也就越少。</p><p>同样，浏览器必须下载的关键字节越少，那么它处理内容并使其呈现在屏幕上的速度就越快。要减少字节数，可以减少资源数量（删除相应资源或者将其设为非关键资源）；同时还可压缩和优化各个资源，以尽量降低传输量。</p><p>最终，关键路径长度是网页所需的所有关键资源与其字节大小之间的依赖图函数：有些资源只有在上一个资源处理完毕后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p><p>换言之，资源数量、字节数和关键路径长度相互关联，但是并不完全相同。例如，您也许无法减少关键资源数量，或者无法缩短关键路径长度，但是减少关键字节数，仍能对优化起到重要作用；反之亦然。</p><p><strong>优化关键呈现路径常规步骤：</strong></p><ol><li>分析和描述关键路径：资源数量、字节数、长度。</li><li>尽量减少关键资源数量：删除相应资源、延迟下载、标记为异步资源等等。</li><li>优化剩余关键资源的加载顺序：您需要尽早下载所有关键资源，以缩短关键路径长度。</li><li>尽量减少关键字节数，以缩短下载时间（往返次数）。</li></ol>

********

<div><p>Out of date!</p><p>This article's translation is out of date with the English version. <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/page-speed-rules-and-recommendations?hl=en">View in English</a>.</p></div><p>PageSpeed Insights 规则使用背景：优化关键呈现路径时需要注意的地方及其原因。</p><h2>删除阻止呈现的 JavaScript 和 CSS</h2><p>若要尽快完成首次呈现，您需要尽量减少甚至删除（如果有可能）网页所呈现关键资源的数量、尽量减少下载的关键字节数以及尽量缩短关键路径的长度。</p><h2>优化 JavaScript 的使用</h2><p>默认情况下，JavaScript 资源会阻止解析器，除非将其标为 <em>async</em>，或者使用特殊的 JavaScript 代码段进行添加。阻塞解析器的 JavaScript 强制浏览器等待 CSSOM，并暂停 DOM 的构建，继而大大延迟首次呈现的时间。</p><h3><strong>推荐使用异步 JavaScript 资源</strong></h3><p>异步资源会取消阻止文档解析器，使浏览器可以在执行标记之前不会在 CSSOM 上实施阻止。通常，如果可以将标记设置为异步，也就意味着该标记不是首次呈现所必需的 - 考虑在首次呈现之后加载异步标记。</p><h3><strong>延迟解析 JavaScript</strong></h3><p>任何非必需的标记（即对构建首次呈现的内容无关紧要的标记）都应予以延迟，从而尽量降低浏览器呈现网页时所需的工作量。</p><h3><strong>避免运行时间长的 JavaScript</strong></h3><p>运行时间长的 JavaScript 会阻止浏览器构建 DOM、CSSOM 以及呈现网页。因此，任何对首次呈现无关紧要的初始化逻辑和功能都应该延迟执行。如果需要运行较长的初始化序列，可以考虑分割成几个阶段，使浏览器可以间隔处理其他事件。</p><h2>优化 CSS 的使用</h2><p>CSS 是构建呈现树的必备元素，但在首次构建网页时，JavaScript 常常会在 CSS 上实施阻止。应该确保将任何非必需的 CSS 标记为非关键资源（例如 print 或者其他媒体查询），并应确保尽可能减少关键 CSS 数，尽可能缩短传输时间。</p><h3><strong>将 CSS 放入文档的 head 标签内</strong></h3><p>应该尽早在 HTML 文档中指定所有 CSS 资源，使浏览器可以尽早发现<code>&lt;link&gt;</code>标签，并尽早发出 CSS 请求。</p><h3><strong>避免使用 CSS import</strong></h3><p>CSS import (<code>@import</code>) 指令使一个样式表可以从另一个样式表文件中导入规则。但是，应避免使用这些指令，因为这会在关键路径中增加往返次数：只有在收到并解析完带有 @import 规则的 CSS 样式表之后，才会发现导入的 CSS 资源。</p><h3><strong>内联阻止呈现的 CSS</strong></h3><p>为了获得最佳效果，您也许会考虑将关键 CSS 直接内联到 HTML 文档中。这可以在关键路径中减少额外的往返次数。如果方法得当，在只有 HTML 是阻止资源时，就能实现’一次往返’的关键路径长度。</p>
